/** \file linked_list.h
  * \brief Implements a doubly-linked %list
  */
#ifndef GENERIC_STRUCTS_H
#define GENERIC_STRUCTS_H

/** \brief Used to typecast functions to the type expected by the data member data_free_func in list.*/
typedef void (*list_free_func)(void*);

/** \brief A node for a simple linked %list.  
 */
typedef struct list_node_s
{
    void *data;        /**< \brief The data payload for this node. */
    struct list_node_s *prev;   /**< \brief The previous item in the %list. */
    struct list_node_s *next;   /**< \brief The next item in the %list. */
} list_node;
/** \brief The container for a simple linked %list. 
  *
  * A simple linked %list implementation. Holds an arbitrarily long %list of items, which must be of the same type.
 */
typedef struct
{
    list_node *start;   /**< \brief The start node of the %list. */
    list_node *end;     /**< \brief The end node of the %list. */
    list_free_func data_free_func; /**< \brief A function used to free each node's data. */
} list;

/** \brief Error codes generated by list_push(), list_push_node(), list_unshift(), and list_unshift_node()
  *
  */
enum linked_list_errors
{
    E_LINKED_LIST_NULL_NEEDLE = 1, /**< \brief Thrown when a null needle is passed */
    E_LINKED_LIST_NULL_HAYSTACK,   /**< \brief Thrown when a null haystack is passed */
    E_LINKED_LIST_OUT_OF_MEM       /**< \brief Thrown when malloc fails to allocate memory */
};

/** \name List Creation/Destruction Functions
  * Functions to create and destroy lists and their members.
  */
/*@{*/

/** \brief Creates a new list
  * \param[in] node_free_func A function to use to free the payload in each list_node. Functions passed must take one argument, the data payload of the node, and have a return type of \a void. Pass NULL if you just want to use free().
  * \return A new list, or NULL if there was no memory left.
  *
  * Initializes new linked lists. Use list_free() to free the memory allocated by this function.
  */
list *list_new(list_free_func node_free_func);

/** \brief Frees memory allocated by a list and all its list_node children.
  * \param[in] doomed A list to be freed
  * \return void
  *
  * Frees the memory of the list allocated by list_new(), and all the members of the %list (and their corresponding list_node structs,) including the data payloads (using the function passed to list_new() during list creation.)
  */
void list_free(list *doomed);

/** \brief Frees memory allocated by the creation of a list_node.
  * \param[in] doomed          The list node to be freed
  * \param[in] node_free_func  A function to use to free the data in the node, or NULL to use free().
  * \return void
  *
  * Frees the memory used by the passed list_node, and frees the data attached to the list_node using the supplied function, if any.
  */
void list_node_free(list_node *doomed, list_free_func node_free_func);

/*@}*/

/** \name List manipulation functions (manual memory management)
  *
  * These functions avoid rapid allocation and freeing of memory, so they should be used whenever possible.
  */
/*@{*/
/** \brief Pushes a list_node onto the end of a list.
  * \param[in] haystack The list upon which the node should be pushed
  * \param[in] needle   The list_node to append to the list
  * \return 0 on success, non-zero member of #linked_list_errors on error
  *
  * You are responsible for creating the list_node needle.
  */
int        list_push_node(list *haystack, list_node *needle);

/** \brief Pops a list_node off of the end of a list.
  * \param[in] haystack The list from which a node is to be taken
  * \return The last list_node of the passed list, or NULL if the list is empty or haystack is NULL
  *
  * This function \b DOES \b NOT free the list_node; you must do it yourself.
  */
list_node *list_pop_node(list *haystack);

/** \brief Adds a list_node to the front of a list.
  * \param[in] haystack The list upon which the node should be added
  * \param[in] needle The list_node to prepend to the list
  * \return 0 on success, non-zero member of #linked_list_errors on error
  *
  * You are responsible for creating the list_node needle.
  */
int        list_unshift_node(list *haystack, list_node *needle);

/** \brief Removes the first list_node from a list
  * \param[in] haystack The list from which a node is to be taken
  * \return The last list_node of the passed list, or NULL if the list is empty or haystack is NULL
  *
  * This function \b DOES \b NOT free the list_node; you must do it yourself.
  */
list_node *list_shift_node(list *haystack);
/*@}*/

/** \name List manipulation functions (automatic memory management)
  *
  * These functions allocate or free memory every time they are called, and should be avoided if you are doing something such as popping a value off a list in order to push it onto a second list. 
  */
/*@{*/
/** \brief Pushes data onto the end of a list
  * \param[in] haystack The list upon which to append the data
  * \param[in] data The data to append
  * \return 0 on success, non-zero member of #linked_list_errors on error
  *
  * This function automatically creates a list_node to hold the data.
  */
int  list_push(list *haystack, void *data);

/** \brief Pops data off the end of a list
  * \param[in] haystack The list from which the data is taken
  * \return The pointer to the data on the last element of the list, or NULL when there are no %list members left or haystack is NULL
  *
  * This function automatically frees the list_node that held the data, but you are responsible for freeing the data.
  */
void *list_pop(list *haystack);

/** \brief Pushes data onto the beginning of a list
  * \param[in] haystack The list upon which to prepend the data
  * \param[in] data The data to prepend
  * \return 0 on success, non-zero member of #linked_list_errors on error
  *
  * This function automatically creates a list_node to hold the data.
  */
int  list_unshift(list *haystack, void *data);

/** \brief Pops data off the front of a list
  * \param[in] haystack The list from which the data is taken
  * \return The pointer to the data on the first element of the list, or NULL when there are no %list members left or haystack is NULL
  *
  * This function automatically frees the list_node that held the data, but you are responsible for freeing the data.
  */
void *list_shift(list *haystack);
/*@}*/

#endif
